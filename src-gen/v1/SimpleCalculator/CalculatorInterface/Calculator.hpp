/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.12.v201705291619.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/*
 * description: 
 * The interface provies APIs to perform calculator operations * author: 
 * Module Owner Name
 */
#ifndef V1_SIMPLECALCULATOR_CALCULATORINTERFACE_CALCULATOR_HPP_
#define V1_SIMPLECALCULATOR_CALCULATORINTERFACE_CALCULATOR_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/ByteBuffer.hpp>
#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace SimpleCalculator {
namespace CalculatorInterface {

class Calculator {
public:
    virtual ~Calculator() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct DIVISION_ERROR : CommonAPI::Enumeration< int32_t> {
        enum Literal : int32_t {
            NO_ERROR = 0,
            DIVIDE_BYZERO = 1,
            DIV_OVERFLOW = 2,
            DIV_UNDERFLOW = 3
        };
    
        DIVISION_ERROR()
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(Literal::NO_ERROR)) {}
        DIVISION_ERROR(Literal _literal)
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< int32_t>(Literal::NO_ERROR):
                case static_cast< int32_t>(Literal::DIVIDE_BYZERO):
                case static_cast< int32_t>(Literal::DIV_OVERFLOW):
                case static_cast< int32_t>(Literal::DIV_UNDERFLOW):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DIVISION_ERROR &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DIVISION_ERROR &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DIVISION_ERROR &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DIVISION_ERROR &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DIVISION_ERROR &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DIVISION_ERROR &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< int32_t>(_value)); }
    };
    /*
     * description: 
     * one array for each basic type
     */
    typedef std::vector< uint8_t> MyArray01;
    typedef std::vector< uint16_t> MyArray02;
    typedef std::vector< uint32_t> MyArray03;
    typedef std::vector< uint64_t> MyArray04;
    typedef std::vector< CommonAPI::ByteBuffer> MyArray05;
    
    struct MetadataType : CommonAPI::Enumeration< int32_t> {
        enum Literal : int32_t {
            MEDIA_METADATATYPE_TITLE = 1,
            MEDIA_METADATATYPE_ALBUM = 2,
            MEDIA_METADATATYPE_ARTIST = 4,
            MEDIA_METADATATYPE_GENRE = 8,
            MEDIA_METADATATYPE_YEAR = 16,
            MEDIA_METADATATYPE_COMPOSER = 32,
            MEDIA_METADATATYPE_TRACK_NUMBER = 64,
            MEDIA_METADATATYPE_TRACK_ALBUMART = 128,
            MEDIA_METADATATYPE_TRACK_UID = 256
        };
    
        MetadataType()
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(Literal::MEDIA_METADATATYPE_TITLE)) {}
        MetadataType(Literal _literal)
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_TITLE):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_ALBUM):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_ARTIST):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_GENRE):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_YEAR):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_COMPOSER):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_TRACK_NUMBER):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_TRACK_ALBUMART):
                case static_cast< int32_t>(Literal::MEDIA_METADATATYPE_TRACK_UID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MetadataType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MetadataType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MetadataType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MetadataType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MetadataType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MetadataType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< int32_t>(_value)); }
    };
    
    struct MetadataFormat : CommonAPI::Enumeration< int32_t> {
        enum Literal : int32_t {
            METADATAFORMAT_INTEGER = 0,
            METADATAFORMAT_STRING = 1
        };
    
        MetadataFormat()
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(Literal::METADATAFORMAT_INTEGER)) {}
        MetadataFormat(Literal _literal)
            : CommonAPI::Enumeration< int32_t>(static_cast< int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< int32_t>(Literal::METADATAFORMAT_INTEGER):
                case static_cast< int32_t>(Literal::METADATAFORMAT_STRING):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MetadataFormat &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MetadataFormat &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MetadataFormat &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MetadataFormat &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MetadataFormat &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MetadataFormat &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< int32_t>(_value)); }
    };
    struct MetadataElement : CommonAPI::Struct< MetadataType, MetadataFormat, std::string, uint32_t> {
    
        MetadataElement()
        {
            std::get< 0>(values_) = MetadataType();
            std::get< 1>(values_) = MetadataFormat();
            std::get< 2>(values_) = "";
            std::get< 3>(values_) = 0ul;
        }
        MetadataElement(const MetadataType &_type, const MetadataFormat &_format, const std::string &_stringValue, const uint32_t &_integerValue)
        {
            std::get< 0>(values_) = _type;
            std::get< 1>(values_) = _format;
            std::get< 2>(values_) = _stringValue;
            std::get< 3>(values_) = _integerValue;
        }
        inline const MetadataType &getType() const { return std::get< 0>(values_); }
        inline void setType(const MetadataType &_value) { std::get< 0>(values_) = _value; }
        inline const MetadataFormat &getFormat() const { return std::get< 1>(values_); }
        inline void setFormat(const MetadataFormat &_value) { std::get< 1>(values_) = _value; }
        inline const std::string &getStringValue() const { return std::get< 2>(values_); }
        inline void setStringValue(const std::string &_value) { std::get< 2>(values_) = _value; }
        inline const uint32_t &getIntegerValue() const { return std::get< 3>(values_); }
        inline void setIntegerValue(const uint32_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const MetadataElement& _other) const {
        return (getType() == _other.getType() && getFormat() == _other.getFormat() && getStringValue() == _other.getStringValue() && getIntegerValue() == _other.getIntegerValue());
        }
        inline bool operator!=(const MetadataElement &_other) const {
            return !((*this) == _other);
        }
    
    };
    typedef std::vector< Calculator::MetadataElement> MetadataElementList;
};

const char* Calculator::getInterface() {
    return ("SimpleCalculator.CalculatorInterface.Calculator:v1_0");
}

CommonAPI::Version Calculator::getInterfaceVersion() {
    return CommonAPI::Version(1, 0);
}

/*
 * description: 
 * Enum for division errors.
 */
/*
 * description: 
 * one array for each basic type
 */
/*
 * description: 
 */

} // namespace CalculatorInterface
} // namespace SimpleCalculator
} // namespace v1

namespace CommonAPI {
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_SIMPLECALCULATOR_CALCULATORINTERFACE_CALCULATOR_HPP_
